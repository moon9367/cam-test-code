import sys
import cv2
import threading
import json
import os
import time
import psutil
from datetime import datetime, timedelta
from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel, QVBoxLayout, QHBoxLayout,
    QLineEdit, QPushButton, QGridLayout, QSizePolicy, QComboBox, QMessageBox,
    QDialog, QFormLayout, QFileDialog, QScrollArea, QCheckBox, QGroupBox,
    QMainWindow, QStatusBar, QProgressBar, QSlider, QFrame, QSplitter,
    QTabWidget, QTextEdit, QListWidget, QListWidgetItem, QToolButton,
    QMenu, QAction, QSystemTrayIcon, QStyle, QDesktopWidget, QInputDialog
)
from PyQt5.QtGui import QImage, QPixmap, QIcon, QFont, QPalette, QColor, QPainter, QPen
from PyQt5.QtCore import Qt, pyqtSignal, QTimer, QPropertyAnimation, QEasingCurve, QThread, pyqtProperty

# AI Í∞úÏÑ†Îêú ÏÑ§Ï†ï
CONFIG_FILE = "ai_cam_config.json"
RECORD_INTERVAL = 1800  # 30Î∂Ñ
MAX_CONCURRENT_STREAMS = 12
STREAM_RESOLUTION = "640x480"
RECORD_RESOLUTION = "1920x1080"

# RTSP ÏµúÏ†ÅÌôî ÏÑ§Ï†ï
RTSP_TCP_OPTIONS = "rtsp_transport;tcp|stimeout;30000000|fflags;nobuffer|flags;low_delay|reorder_queue_size;0|max_delay;0|analyzeduration;2000000|probesize;1000000|max_probe_packets;1000|err_detect;ignore_err|skip_frame;nokey|skip_loop_filter;48|tune;zerolatency"
RTSP_UDP_OPTIONS = "rtsp_transport;udp|stimeout;30000000|fflags;nobuffer|flags;low_delay|reorder_queue_size;0|max_delay;0|analyzeduration;2000000|probesize;1000000|max_probe_packets;1000|err_detect;ignore_err|skip_frame;nokey|skip_loop_filter;48|tune;zerolatency"

class SmartCameraStream(threading.Thread):
    """AI Í∞úÏÑ†Îêú Ïπ¥Î©îÎùº Ïä§Ìä∏Î¶º ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, camera_id, label, camera_index, rtsp_url=None, record_dir=None, resolution="640x480"):
        super().__init__()
        self.camera_id = camera_id
        self.camera_index = camera_index
        self.rtsp_url = rtsp_url
        self.label = label
        self.running = True
        self.cap = None
        self.record_dir = record_dir
        self.last_record_time = 0
        self.writer = None
        self.is_recording = False
        
        # AI Ïä§ÎßàÌä∏ Í∏∞Îä•
        self.connection_quality = 0.0  # 0-100
        self.frame_drop_rate = 0.0
        self.last_frame_time = time.time()
        self.frame_count = 0
        self.error_count = 0
        self.reconnect_count = 0
        self.auto_reconnect = True
        
        # Ìï¥ÏÉÅÎèÑ ÏÑ§Ï†ï
        self.stream_width, self.stream_height = map(int, resolution.split('x'))
        self.record_width, self.record_height = 1920, 1080
        
        # ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
        self.fps = 0.0
        self.actual_width = 0
        self.actual_height = 0
        
        self.daemon = True
        self.label.setText(f"üìπ Camera {camera_index + 1}\nüîÑ Ï¥àÍ∏∞Ìôî Ï§ë...")

    def get_connection_status(self):
        """Ïó∞Í≤∞ ÏÉÅÌÉúÎ•º Ï†êÏàòÎ°ú Î∞òÌôò (0-100)"""
        if not self.cap or not self.cap.isOpened():
            return 0
        
        # ÌîÑÎ†àÏûÑ ÎìúÎ°≠Î•†, ÏóêÎü¨Ïú®, Ïû¨Ïó∞Í≤∞ ÌöüÏàò Îì±ÏùÑ Ï¢ÖÌï©ÌïòÏó¨ Ï†êÏàò Í≥ÑÏÇ∞
        quality = 100.0
        
        if self.frame_drop_rate > 0.1:  # 10% Ïù¥ÏÉÅ ÎìúÎ°≠
            quality -= 30
        if self.error_count > 5:
            quality -= 20
        if self.reconnect_count > 3:
            quality -= 15
            
        return max(0, min(100, quality))

    def start_recording(self):
        """Ïä§ÎßàÌä∏ ÎÖπÌôî ÏãúÏûë"""
        if not self.record_dir:
            return
            
        if self.writer:
            self.writer.release()
            
        os.makedirs(self.record_dir, exist_ok=True)
        filename = datetime.now().strftime("rec_%Y%m%d_%H%M%S.avi")
        filepath = os.path.join(self.record_dir, filename)
        
        # ÏµúÏ†ÅÌôîÎêú ÏΩîÎç± ÏÑ†ÌÉù
        try:
            fourcc = cv2.VideoWriter_fourcc(*'H264')
            self.writer = cv2.VideoWriter(filepath, fourcc, 30.0, (self.record_width, self.record_height))
            if not self.writer.isOpened():
                fourcc = cv2.VideoWriter_fourcc(*'XVID')
                self.writer = cv2.VideoWriter(filepath, fourcc, 30.0, (self.record_width, self.record_height))
        except:
            fourcc = cv2.VideoWriter_fourcc(*'MJPG')
            self.writer = cv2.VideoWriter(filepath, fourcc, 30.0, (self.record_width, self.record_height))
            
        if self.writer.isOpened():
            self.last_record_time = time.time()
            print(f"üé¨ Camera {self.camera_index + 1} ÎÖπÌôî ÏãúÏûë: {filename}")

    def stop_recording(self):
        """ÎÖπÌôî Ï§ëÏßÄ"""
        if self.writer:
            self.writer.release()
            self.writer = None
            print(f"‚èπÔ∏è Camera {self.camera_index + 1} ÎÖπÌôî Ï§ëÏßÄ")

    def run(self):
        """AI Í∞úÏÑ†Îêú Ïä§Ìä∏Î¶º Ï≤òÎ¶¨"""
        reconnect_attempts = 0
        max_attempts = 3
        
        while self.running:
            if not self.cap or not self.cap.isOpened():
                if reconnect_attempts >= max_attempts:
                    self.label.setText(f"üìπ Camera {self.camera_index + 1}\n‚ùå Ïó∞Í≤∞ Ïã§Ìå®")
                    self.label.setStyleSheet("background-color: #ff4444; color: white; border-radius: 10px;")
                    break
                    
                self.label.setText(f"üìπ Camera {self.camera_index + 1}\nüîÑ Ïû¨Ïó∞Í≤∞ Ï§ë... ({reconnect_attempts + 1}/{max_attempts})")
                
                if self.cap:
                    self.cap.release()
                self.cap = None
                
                try:
                    if self.rtsp_url:
                        # DNS ÌôïÏù∏
                        import socket
                        try:
                            if '@' in self.rtsp_url:
                                host = self.rtsp_url.split('@')[1].split(':')[0]
                            else:
                                host = self.rtsp_url.split('://')[1].split(':')[0]
                            socket.gethostbyname(host)
                        except:
                            pass
                        
                        # TCP ÏãúÎèÑ
                        os.environ["OPENCV_FFMPEG_CAPTURE_OPTIONS"] = RTSP_TCP_OPTIONS
                        self.cap = cv2.VideoCapture(self.rtsp_url, cv2.CAP_FFMPEG)
                        
                        if not self.cap.isOpened():
                            # UDP ÏãúÎèÑ
                            os.environ["OPENCV_FFMPEG_CAPTURE_OPTIONS"] = RTSP_UDP_OPTIONS
                            self.cap = cv2.VideoCapture(self.rtsp_url, cv2.CAP_FFMPEG)
                            
                    elif isinstance(self.camera_id, int):
                        self.cap = cv2.VideoCapture(self.camera_id, cv2.CAP_DSHOW)
                        self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 3)
                    
                    # Ïó∞Í≤∞ ÎåÄÍ∏∞
                    start_time = time.time()
                    while not self.cap.isOpened():
                        if time.time() - start_time > 30:
                            raise Exception("Ïó∞Í≤∞ ÏãúÍ∞Ñ Ï¥àÍ≥º")
                        time.sleep(0.5)
                    
                    # Ïπ¥Î©îÎùº ÏÑ§Ï†ï
                    self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 9999)
                    self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 9999)
                    self.cap.set(cv2.CAP_PROP_FPS, 30)
                    
                    self.actual_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                    self.actual_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                    self.fps = self.cap.get(cv2.CAP_PROP_FPS)
                    
                    if self.fps <= 0.1 or self.fps > 60:
                        self.fps = 30.0
                    
                    # ÏµúÏ†Å ÏÑ§Ï†ï Ï†ÅÏö©
                    self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.actual_width)
                    self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.actual_height)
                    self.cap.set(cv2.CAP_PROP_FPS, self.fps)
                    
                    reconnect_attempts = 0
                    self.reconnect_count += 1
                    
                except Exception as e:
                    print(f"Camera {self.camera_index + 1} Ïó∞Í≤∞ Ïã§Ìå®: {e}")
                    reconnect_attempts += 1
                    time.sleep(1)
                    continue
            
            # ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨
            try:
                ret, frame = self.cap.read()
                
                if not ret or frame is None:
                    self.error_count += 1
                    self.label.setText(f"üìπ Camera {self.camera_index + 1}\n‚ö†Ô∏è ÌîÑÎ†àÏûÑ Ïò§Î•ò")
                    time.sleep(0.1)
                    continue
                
                # ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
                current_time = time.time()
                self.frame_count += 1
                
                if current_time - self.last_frame_time > 0:
                    self.frame_drop_rate = 1.0 - (self.frame_count / (self.fps * (current_time - self.last_frame_time)))
                
                # ÎÖπÌôî Ï≤òÎ¶¨
                if self.is_recording and self.record_dir:
                    now = time.time()
                    if self.writer is None or (now - self.last_record_time > RECORD_INTERVAL):
                        self.start_recording()
                    
                    if self.writer and frame is not None:
                        if frame.shape[1] != self.record_width or frame.shape[0] != self.record_height:
                            resized_frame = cv2.resize(frame, (self.record_width, self.record_height))
                        else:
                            resized_frame = frame
                        self.writer.write(resized_frame)
                
                # ÌôîÎ©¥ ÌëúÏãú
                if frame is not None:
                    # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Ï∂îÍ∞Ä
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    cv2.putText(frame, timestamp, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
                    
                    # ÏÉÅÌÉú Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                    status_text = f"FPS: {self.fps:.1f} | Quality: {self.get_connection_status():.0f}%"
                    cv2.putText(frame, status_text, (10, frame.shape[0] - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
                    
                    # ÌôîÎ©¥Ïóê ÌëúÏãú
                    rgb_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    h, w, ch = rgb_image.shape
                    bytes_per_line = ch * w
                    qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
                    
                    pixmap = QPixmap.fromImage(qt_image).scaled(
                        self.label.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation
                    )
                    self.label.setPixmap(pixmap)
                    
                    # Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    quality = self.get_connection_status()
                    if quality > 80:
                        self.label.setStyleSheet("background-color: #44ff44; color: white; border-radius: 10px;")
                    elif quality > 50:
                        self.label.setStyleSheet("background-color: #ffaa44; color: white; border-radius: 10px;")
                    else:
                        self.label.setStyleSheet("background-color: #ff4444; color: white; border-radius: 10px;")
                
                time.sleep(1.0 / self.fps if self.fps > 0 else 0.033)
                
            except Exception as e:
                self.error_count += 1
                print(f"Camera {self.camera_index + 1} ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
                time.sleep(0.1)
        
        if self.cap:
            self.cap.release()
        if self.writer:
            self.writer.release()

    def stop(self):
        """Ïä§Ìä∏Î¶º Ï§ëÏßÄ"""
        self.running = False
        self.is_recording = False
        self.stop_recording()
        self.join()

class SystemMonitor(QThread):
    """ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú"""
    system_update = pyqtSignal(dict)
    
    def run(self):
        while True:
            cpu_percent = psutil.cpu_percent()
            memory = psutil.virtual_memory()
            disk = psutil.disk_usage('/')
            
            self.system_update.emit({
                'cpu': cpu_percent,
                'memory': memory.percent,
                'disk': disk.percent
            })
            
            time.sleep(2)

class SmartCameraViewer(QMainWindow):
    """AI Í∞úÏÑ†Îêú Î©îÏù∏ ÏúàÎèÑÏö∞"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ü§ñ AI Smart Camera Monitor")
        self.setGeometry(100, 100, 1400, 900)
        
        # Îç∞Ïù¥ÌÑ∞
        self.cameras = []
        self.streams = []
        self.is_recording = False
        self.expanded_camera = None
        
        # ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞
        self.system_monitor = SystemMonitor()
        self.system_monitor.system_update.connect(self.update_system_status)
        self.system_monitor.start()
        
        # UI Ï¥àÍ∏∞Ìôî
        self.init_ui()
        self.load_config()
        
        # ÏãúÏä§ÌÖú Ìä∏Î†àÏù¥
        self.setup_system_tray()
        
        # ÏûêÎèô Ï†ÄÏû• ÌÉÄÏù¥Î®∏
        self.auto_save_timer = QTimer()
        self.auto_save_timer.timeout.connect(self.auto_save_config)
        self.auto_save_timer.start(30000)  # 30Ï¥àÎßàÎã§ ÏûêÎèô Ï†ÄÏû•

    def init_ui(self):
        """UI Ï¥àÍ∏∞Ìôî"""
        # Ï§ëÏïô ÏúÑÏ†Ø
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Î©îÏù∏ Î†àÏù¥ÏïÑÏõÉ
        main_layout = QHBoxLayout()
        central_widget.setLayout(main_layout)
        
        # ÏôºÏ™Ω Ìå®ÎÑê (Ïª®Ìä∏Î°§)
        left_panel = self.create_control_panel()
        main_layout.addWidget(left_panel, 1)
        
        # Ïò§Î•∏Ï™Ω Ìå®ÎÑê (Ïπ¥Î©îÎùº Î∑∞)
        right_panel = self.create_camera_panel()
        main_layout.addWidget(right_panel, 4)
        
        # ÏÉÅÌÉúÎ∞î
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        
        # ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌëúÏãú
        self.cpu_label = QLabel("CPU: 0%")
        self.memory_label = QLabel("RAM: 0%")
        self.disk_label = QLabel("DISK: 0%")
        
        self.status_bar.addPermanentWidget(self.cpu_label)
        self.status_bar.addPermanentWidget(self.memory_label)
        self.status_bar.addPermanentWidget(self.disk_label)
        
        # Ïä§ÌÉÄÏùº Ï†ÅÏö©
        self.apply_dark_theme()

    def create_control_panel(self):
        """Ïª®Ìä∏Î°§ Ìå®ÎÑê ÏÉùÏÑ±"""
        panel = QFrame()
        panel.setFrameStyle(QFrame.StyledPanel)
        panel.setMaximumWidth(300)
        
        layout = QVBoxLayout()
        panel.setLayout(layout)
        
        # Ï†úÎ™©
        title = QLabel("üéõÔ∏è Ï†úÏñ¥ Ìå®ÎÑê")
        title.setFont(QFont("Arial", 16, QFont.Bold))
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # Îπ†Î•∏ ÏãúÏûë Î≤ÑÌäº
        quick_start_btn = QPushButton("üöÄ Îπ†Î•∏ ÏãúÏûë")
        quick_start_btn.clicked.connect(self.quick_start)
        quick_start_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border: none;
                padding: 10px;
                border-radius: 5px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        layout.addWidget(quick_start_btn)
        
        # ÎÖπÌôî Ïª®Ìä∏Î°§
        record_group = QGroupBox("üé¨ ÎÖπÌôî Ï†úÏñ¥")
        record_layout = QVBoxLayout()
        record_group.setLayout(record_layout)
        
        self.record_btn = QPushButton("‚è∫Ô∏è ÎÖπÌôî ÏãúÏûë")
        self.record_btn.clicked.connect(self.toggle_recording)
        record_layout.addWidget(self.record_btn)
        
        self.record_status = QLabel("ÎÖπÌôî Ï§ëÏßÄÎê®")
        self.record_status.setAlignment(Qt.AlignCenter)
        record_layout.addWidget(self.record_status)
        
        layout.addWidget(record_group)
        
        # Ïπ¥Î©îÎùº Í¥ÄÎ¶¨
        camera_group = QGroupBox("üìπ Ïπ¥Î©îÎùº Í¥ÄÎ¶¨")
        camera_layout = QVBoxLayout()
        camera_group.setLayout(camera_layout)
        
        self.camera_list = QListWidget()
        self.camera_list.itemClicked.connect(self.on_camera_selected)
        camera_layout.addWidget(self.camera_list)
        
        # Ïπ¥Î©îÎùº Ï∂îÍ∞Ä/Ï†úÍ±∞ Î≤ÑÌäº
        btn_layout = QHBoxLayout()
        add_btn = QPushButton("‚ûï Ï∂îÍ∞Ä")
        add_btn.clicked.connect(self.add_camera)
        remove_btn = QPushButton("‚ûñ Ï†úÍ±∞")
        remove_btn.clicked.connect(self.remove_camera)
        
        btn_layout.addWidget(add_btn)
        btn_layout.addWidget(remove_btn)
        camera_layout.addLayout(btn_layout)
        
        layout.addWidget(camera_group)
        
        # ÏÑ§Ï†ï
        settings_group = QGroupBox("‚öôÔ∏è ÏÑ§Ï†ï")
        settings_layout = QVBoxLayout()
        settings_group.setLayout(settings_layout)
        
        settings_btn = QPushButton("üîß Í≥†Í∏â ÏÑ§Ï†ï")
        settings_btn.clicked.connect(self.open_settings)
        settings_layout.addWidget(settings_btn)
        
        layout.addWidget(settings_group)
        
        # Î°úÍ∑∏
        log_group = QGroupBox("üìã ÏãúÏä§ÌÖú Î°úÍ∑∏")
        log_layout = QVBoxLayout()
        log_group.setLayout(log_layout)
        
        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(150)
        self.log_text.setReadOnly(True)
        log_layout.addWidget(self.log_text)
        
        layout.addWidget(log_group)
        
        layout.addStretch()
        
        return panel

    def create_camera_panel(self):
        """Ïπ¥Î©îÎùº Ìå®ÎÑê ÏÉùÏÑ±"""
        panel = QFrame()
        panel.setFrameStyle(QFrame.StyledPanel)
        
        layout = QVBoxLayout()
        panel.setLayout(layout)
        
        # Ï†úÎ™©
        title = QLabel("üì∫ Ïπ¥Î©îÎùº Î∑∞")
        title.setFont(QFont("Arial", 16, QFont.Bold))
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # Ïπ¥Î©îÎùº Í∑∏Î¶¨Îìú
        self.camera_grid = QGridLayout()
        self.camera_grid.setSpacing(5)
        
        # 12Í∞ú Ïπ¥Î©îÎùº ÎùºÎ≤® ÏÉùÏÑ±
        for i in range(12):
            label = QLabel(f"üìπ Camera {i + 1}\n‚è≥ ÎåÄÍ∏∞ Ï§ë...")
            label.setAlignment(Qt.AlignCenter)
            label.setStyleSheet("""
                QLabel {
                    background-color: #2b2b2b;
                    color: white;
                    border: 2px solid #444;
                    border-radius: 10px;
                    padding: 10px;
                    font-size: 12px;
                }
                QLabel:hover {
                    border-color: #666;
                }
            """)
            label.mouseDoubleClickEvent = self.make_double_click_handler(label, i)
            
            row, col = divmod(i, 4)
            self.camera_grid.addWidget(label, row, col)
            self.cameras.append(label)
        
        layout.addLayout(self.camera_grid)
        
        return panel

    def apply_dark_theme(self):
        """Îã§ÌÅ¨ ÌÖåÎßà Ï†ÅÏö©"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
                color: white;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #444;
                border-radius: 5px;
                margin-top: 1ex;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
            QPushButton {
                background-color: #444;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #555;
            }
            QPushButton:pressed {
                background-color: #333;
            }
            QListWidget {
                background-color: #2b2b2b;
                color: white;
                border: 1px solid #444;
                border-radius: 4px;
            }
            QTextEdit {
                background-color: #2b2b2b;
                color: white;
                border: 1px solid #444;
                border-radius: 4px;
            }
            QStatusBar {
                background-color: #2b2b2b;
                color: white;
            }
        """)

    def setup_system_tray(self):
        """ÏãúÏä§ÌÖú Ìä∏Î†àÏù¥ ÏÑ§Ï†ï"""
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setIcon(self.style().standardIcon(QStyle.SP_ComputerIcon))
        
        # Ìä∏Î†àÏù¥ Î©îÎâ¥
        tray_menu = QMenu()
        show_action = QAction("Î≥¥Ïù¥Í∏∞", self)
        show_action.triggered.connect(self.show)
        tray_menu.addAction(show_action)
        
        quit_action = QAction("Ï¢ÖÎ£å", self)
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)
        
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.show()

    def quick_start(self):
        """Îπ†Î•∏ ÏãúÏûë"""
        self.log_message("üöÄ Îπ†Î•∏ ÏãúÏûë Ïã§Ìñâ Ï§ë...")
        
        # Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏûêÎèô ÏãúÏûë
        if not self.streams:
            self.start_all_cameras()
        
        self.log_message("‚úÖ Îπ†Î•∏ ÏãúÏûë ÏôÑÎ£å!")

    def start_all_cameras(self):
        """Î™®Îì† Ïπ¥Î©îÎùº ÏãúÏûë"""
        self.log_message("üìπ Ïπ¥Î©îÎùº Ïó∞Í≤∞ ÏãúÏûë...")
        
        for i, camera in enumerate(self.cameras):
            if i < len(self.cameras):
                # Í∏∞Î≥∏ RTSP URLÎ°ú ÏãúÏûë (ÏÑ§Ï†ïÏóêÏÑú Î°úÎìú)
                rtsp_url = f"rtsp://camera{i+1}.local:554/stream1"
                stream = SmartCameraStream(i, camera, i, rtsp_url=rtsp_url)
                self.streams.append(stream)
                stream.start()
                
                time.sleep(0.5)  # ÏàúÏ∞® Ïó∞Í≤∞
        
        self.log_message("‚úÖ Î™®Îì† Ïπ¥Î©îÎùº Ïó∞Í≤∞ ÏôÑÎ£å!")

    def toggle_recording(self):
        """ÎÖπÌôî ÌÜ†Í∏Ä"""
        if not self.is_recording:
            self.start_recording()
        else:
            self.stop_recording()

    def start_recording(self):
        """ÎÖπÌôî ÏãúÏûë"""
        self.is_recording = True
        self.record_btn.setText("‚èπÔ∏è ÎÖπÌôî Ï§ëÏßÄ")
        self.record_status.setText("ÎÖπÌôî Ï§ë...")
        self.record_btn.setStyleSheet("background-color: #f44336; color: white;")
        
        for stream in self.streams:
            stream.is_recording = True
        
        self.log_message("üé¨ ÎÖπÌôî ÏãúÏûë!")
        self.tray_icon.showMessage("ÎÖπÌôî ÏãúÏûë", "Î™®Îì† Ïπ¥Î©îÎùºÏóêÏÑú ÎÖπÌôîÍ∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.")

    def stop_recording(self):
        """ÎÖπÌôî Ï§ëÏßÄ"""
        self.is_recording = False
        self.record_btn.setText("‚è∫Ô∏è ÎÖπÌôî ÏãúÏûë")
        self.record_status.setText("ÎÖπÌôî Ï§ëÏßÄÎê®")
        self.record_btn.setStyleSheet("background-color: #4CAF50; color: white;")
        
        for stream in self.streams:
            stream.is_recording = False
        
        self.log_message("‚èπÔ∏è ÎÖπÌôî Ï§ëÏßÄ!")
        self.tray_icon.showMessage("ÎÖπÌôî Ï§ëÏßÄ", "Î™®Îì† Ïπ¥Î©îÎùºÏóêÏÑú ÎÖπÌôîÍ∞Ä Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.")

    def add_camera(self):
        """Ïπ¥Î©îÎùº Ï∂îÍ∞Ä"""
        # Í∞ÑÎã®Ìïú Ïπ¥Î©îÎùº Ï∂îÍ∞Ä Îã§Ïù¥ÏñºÎ°úÍ∑∏
        url, ok = QInputDialog.getText(self, "Ïπ¥Î©îÎùº Ï∂îÍ∞Ä", "RTSP URL:")
        if ok and url:
            camera_id = len(self.streams)
            stream = SmartCameraStream(camera_id, self.cameras[camera_id], camera_id, rtsp_url=url)
            self.streams.append(stream)
            stream.start()
            
            self.log_message(f"‚ûï Ïπ¥Î©îÎùº {camera_id + 1} Ï∂îÍ∞ÄÎê®: {url}")

    def remove_camera(self):
        """Ïπ¥Î©îÎùº Ï†úÍ±∞"""
        if self.streams:
            stream = self.streams.pop()
            stream.stop()
            self.log_message(f"‚ûñ Ïπ¥Î©îÎùº {stream.camera_index + 1} Ï†úÍ±∞Îê®")

    def on_camera_selected(self, item):
        """Ïπ¥Î©îÎùº ÏÑ†ÌÉùÎê®"""
        camera_id = item.data(Qt.UserRole)
        self.log_message(f"üìπ Ïπ¥Î©îÎùº {camera_id + 1} ÏÑ†ÌÉùÎê®")

    def make_double_click_handler(self, label, index):
        """ÎçîÎ∏îÌÅ¥Î¶≠ Ìï∏Îì§Îü¨"""
        def handler(event):
            if self.expanded_camera == label:
                # Ï∂ïÏÜå
                self.expanded_camera = None
                self.restore_grid()
            else:
                # ÌôïÎåÄ
                self.expanded_camera = label
                self.expand_camera(label)
        return handler

    def expand_camera(self, label):
        """Ïπ¥Î©îÎùº ÌôïÎåÄ"""
        # Í∑∏Î¶¨ÎìúÏóêÏÑú Î™®Îì† ÎùºÎ≤® Ïà®Í∏∞Í∏∞
        for i in range(self.camera_grid.count()):
            item = self.camera_grid.itemAt(i)
            if item.widget():
                item.widget().setVisible(False)
        
        # ÏÑ†ÌÉùÎêú ÎùºÎ≤®Îßå ÌëúÏãúÌïòÍ≥† ÌÅ¨Í≤å
        label.setVisible(True)
        self.camera_grid.addWidget(label, 0, 0, 3, 4)

    def restore_grid(self):
        """Í∑∏Î¶¨Îìú Î≥µÏõê"""
        # Î™®Îì† ÎùºÎ≤® Îã§Ïãú ÌëúÏãú
        for i, label in enumerate(self.cameras):
            label.setVisible(True)
            row, col = divmod(i, 4)
            self.camera_grid.addWidget(label, row, col, 1, 1)

    def update_system_status(self, status):
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏"""
        self.cpu_label.setText(f"CPU: {status['cpu']:.1f}%")
        self.memory_label.setText(f"RAM: {status['memory']:.1f}%")
        self.disk_label.setText(f"DISK: {status['disk']:.1f}%")

    def log_message(self, message):
        """Î°úÍ∑∏ Î©îÏãúÏßÄ Ï∂îÍ∞Ä"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.append(f"[{timestamp}] {message}")

    def open_settings(self):
        """ÏÑ§Ï†ï Ïó¥Í∏∞"""
        QMessageBox.information(self, "ÏÑ§Ï†ï", "Í≥†Í∏â ÏÑ§Ï†ï Í∏∞Îä•ÏùÄ Í∞úÎ∞ú Ï§ëÏûÖÎãàÎã§.")

    def load_config(self):
        """ÏÑ§Ï†ï Î°úÎìú"""
        if os.path.exists(CONFIG_FILE):
            try:
                with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.log_message("üìÇ ÏÑ§Ï†ï ÌååÏùº Î°úÎìúÎê®")
            except:
                self.log_message("‚ö†Ô∏è ÏÑ§Ï†ï ÌååÏùº Î°úÎìú Ïã§Ìå®")
        else:
            self.log_message("üìù ÏÉà ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±Îê®")

    def auto_save_config(self):
        """ÏûêÎèô ÏÑ§Ï†ï Ï†ÄÏû•"""
        try:
            config = {
                'cameras': [],
                'settings': {
                    'recording_interval': RECORD_INTERVAL,
                    'max_streams': MAX_CONCURRENT_STREAMS
                }
            }
            
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=4, ensure_ascii=False)
        except:
            pass

    def closeEvent(self, event):
        """ÌîÑÎ°úÍ∑∏Îû® Ï¢ÖÎ£å"""
        # Î™®Îì† Ïä§Ìä∏Î¶º Ï§ëÏßÄ
        for stream in self.streams:
            stream.stop()
        
        # ÏÑ§Ï†ï Ï†ÄÏû•
        self.auto_save_config()
        
        # ÏãúÏä§ÌÖú Ìä∏Î†àÏù¥ÏóêÏÑú Ï†úÍ±∞
        self.tray_icon.hide()
        
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setApplicationName("AI Smart Camera Monitor")
    
    # ÏïÑÏù¥ÏΩò ÏÑ§Ï†ï
    app.setWindowIcon(QIcon("camera_icon.png"))
    
    viewer = SmartCameraViewer()
    viewer.show()
    
    sys.exit(app.exec_()) 